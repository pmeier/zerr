package main

//go:generate go run .
//go:generate go fmt ../zerr_gen.go

import (
	"fmt"
	"html/template"
	"os"
	"reflect"
	"slices"
	"strings"

	"github.com/rs/zerolog"
)

type Parameter struct {
	Name    string
	Type    string
	Forward string
}

type Method struct {
	Name       string
	Parameters []Parameter
}

type Module struct {
	Imports []string
	Methods []Method
}

var moduleTemplate *template.Template = template.Must(template.New("").Parse(`
// DO NOT EDIT: this file is autogenerated. To regenerate invoke
// go generate ./gen
// in the project root

package zerr

import (
{{- range .Imports }}
    "{{ . }}"
{{- end }}
)

{{ range .Methods }}
func (z *Zerr) {{ .Name }}({{ range .Parameters }} {{ .Name }} {{ .Type }}, {{- end}}) *Zerr {
    z.e.{{ .Name }}({{ range .Parameters}} {{ .Forward }}, {{ end }})
    return z
}
{{- end  }}
`))

var excludedMethods []string = []string{
	// not propagated
	"AnErr",
	"Err",
	"Discard",
	"Enabled",
	"GetCtx",
	// handled manually
	"Send",
	"Msg",
	"MsgFunc",
	"Msgf",
}

func main() {
	logger := zerolog.New(os.Stdout)
	e := logger.Fatal()
	r := reflect.TypeOf(e)

	ms := []Method{}
	imports := []string{}
	for i := range r.NumMethod() {
		rm := r.Method(i)
		if slices.Contains(excludedMethods, rm.Name) {
			continue
		}

		m, requiredImports := parseMethod(rm)
		ms = append(ms, m)
		imports = append(imports, requiredImports...)
	}

	f, err := os.Create("../zerr_gen.go")
	if err != nil {
		panic(err.Error())
	}

	slices.Sort(imports)
	imports = slices.Compact(imports)
	if err := moduleTemplate.Execute(f, Module{Imports: imports, Methods: ms}); err != nil {
		panic(err.Error())
	}
}

func parseMethod(m reflect.Method) (Method, []string) {
	if m.Type.NumOut() != 1 {
		// FIXME panic if return type of method is not *zerolog.Event
		//  || m.Type.Out(0) != nil
		panic("oops")
	}

	ni := m.Type.NumIn() - 1

	var pns []string
	switch ni {
	case 0:
	case 1:
		pns = append(pns, "v")
	case 2:
		pns = append(pns, "k", "v")
	default:
		pns = append(pns, "k")
		for i := range ni - 1 {
			pns = append(pns, fmt.Sprintf("v%d", i+1))
		}
	}

	ps := make([]Parameter, 0, ni)
	ris := []string{}
	for i := range ni {
		in := m.Type.In(i + 1)

		if ri := in.PkgPath(); ri != "" {
			ris = append(ris, ri)
		}

		n := pns[i]
		t := in.String()
		var f string
		if i == ni-1 && m.Type.IsVariadic() {
			t = strings.Replace(t, "[]", "...", 1)
			f = fmt.Sprintf("%s...", n)
		} else {
			f = n
		}

		ps = append(ps, Parameter{Name: n, Type: t, Forward: f})
	}

	return Method{Name: m.Name, Parameters: ps}, ris
}
